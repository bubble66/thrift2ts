import { thrift2TsPath, getThriftFileName} from './helpers';

const thriftTypeMapper = {
    'byte': 'ThriftType.BYTE',
    'i16': 'ThriftType.I16',
    'i32': 'ThriftType.I32',
    'i64': 'ThriftType.I64',
    'double': 'ThriftType.DOUBLE',
    'string': 'ThriftType.STRING',
    'list': 'ThriftType.LIST',
    'set': 'ThriftType.SET',
    'map': 'ThriftType.MAP',
    'struct': 'ThriftType.STRUCT',
    'bool': 'ThriftType.BOOL',
    'void': 'ThriftType.VOID',
    'stop': 'ThriftType.STOP'
}

const fieldReaderMapper = {
    'byte': 'input.readByte()',
    'i16': 'input.readI16()',
    'i32': 'input.readI32()',
    'i64': 'input.readI64()',
    'double': 'input.readDouble()',
    'string': 'input.readString()',
    'bool': 'input.readBool()'
}

const fieldWriterMapper = {
    'byte': 'input.writeByte()',
    'i16': 'input.writeI16()',
    'i32': 'input.writeI32()',
    'i64': 'input.writeI64()',
    'double': 'input.writeDouble()',
    'string': 'input.writeString()',
    'bool': 'input.writeBool()'
}

let header = `/**\r\n * This service client is auto-generated by Thrift2Ts.\r\n *\r\n * ${(new Date()).toString()}\r\n */\r\n\r\n`;

// import TException from thrift-browser package
header += `import Thrift from "thrift-browser"\r\n`
header += `const {\r\n    ThriftType,\r\n    MessageType,\r\n    TApplicationException,\r\n    TException,\r\n    IProtocol,\r\n    ProtocolClass,\r\n    ITransport,\r\n    TransportClass\r\n} = Thrift\r\n\r\n`

export default (ast: any, Request = './request'): string => {
    let code = '';

    code += header;

    const defaultExports = [];

    const simplifyType = (type): string|object => {
        if (typeof type === 'string') {
            return type;
        }

        switch (type.name.toLowerCase()) {
            case 'map':
            case 'list':
            case 'set':
                return type;
            default:
                return type.name.toString();
        }
    }

    const mapThriftType = (type) => {
        if (typeof type === 'object') {
            return type.name
        }

        if (Object.keys(thriftTypeMapper).indexOf(type) > -1) {
            return type
        }

        // maybe a custom typedef
        if (Object.keys(ast['typedef']).indexOf(type) > -1) {
            return ast['typedef'][type]['type']['name']
        }

        // maybe a custom enum
        if (Object.keys(ast['enum']).indexOf(type) > -1) {
            return 'i32'
        }

        // maybe a custom map
        if (Object.keys(ast['map']).indexOf(type) > -1) {
            return 'map'
        }

        // maybe a custom list
        if (Object.keys(ast['list']).indexOf(type) > -1) {
            return 'list'
        }

        // maybe a custom set
        if (Object.keys(ast['set']).indexOf(type) > -1) {
            return 'set'
        }

        // maybe a custom struct
        if (Object.keys(ast['struct']).indexOf(type) > -1) {
            return 'struct'
        }

        throw new Error(`Unknown thrift type: ${type}`)
    }

    const getThriftTypeStr = (type) => {
        return thriftTypeMapper[mapThriftType(type)]
    }

    const getReaderStr = (type) => {
        return fieldReaderMapper[mapThriftType(type)]
    }

    const getWriterStr = (type) => {
        return fieldWriterMapper[mapThriftType(type)]
    }

    const valueTypeTransformer = (type): string => {
        type = simplifyType(type);

        if (typeof type === 'string') {
            switch (type) {
                case 'i16':
                case 'i32':
                case 'i64':
                case 'double':
                    return 'number';
                case 'bool':
                    return 'boolean';
                default:
                    return type;
            }
        }

        switch (type['name']) {
            case 'map':
                return `{[key: ${type['keyType']}]: ${valueTypeTransformer(type['valueType'])}}`;
            case 'list':
            case 'set':
                return `${valueTypeTransformer(type['valueType'])}[]`;
        }
        throw new Error(`Unexpected value type: ${JSON.stringify(type)}`);
    }

    const valueTransformer = (value, isMap = false): string => {
        if (typeof value === 'string') {
            return `\"${value}\"`;
        }
        if (['number', 'boolean'].indexOf(typeof value) > -1) {
            return value.toString();
        }
        if (value instanceof Array) {
            if (isMap) {
                return `{${value.map(v => valueTransformer(v)).join(', ')}}`;
            }
            return `[${value.map(v => valueTransformer(v)).join(', ')}]`;
        }
        if (typeof value === 'object' && value['key'] !== undefined && value['value'] !== undefined) {
            return `"${value['key']}": ${valueTransformer(value['value'])}`;
        }
        throw new Error(`Unexpected value: ${JSON.stringify(value)}`);
    }

    const includesHandler = (includes: object[]): string => {
        let imports = '';
        Object.keys(includes).map(key => includes[key]).forEach(include => {
            imports += `\r\nimport * as ${getThriftFileName(include.value)} from "${thrift2TsPath(include.value)}";\r\n`;
        });
        return imports;
    }

    const constsHandler = (consts: object[]): string => {
        let newConsts = '';
        Object.keys(consts).forEach(key => {
            newConsts += `\r\nexport const ${key}: ${valueTypeTransformer(consts[key]['type'])} = ${valueTransformer(consts[key]['value'], typeof consts[key]['type'] === 'object' && consts[key]['type']['name'] === 'map')}; \r\n`;
        });
        return newConsts;
    }

    const enumsHandler = (enums: object[]): string => {
        let newEnums = '';
        Object.keys(enums).forEach(key => {
            newEnums += enumHandler(key, enums[key]['items']);
        })
        return newEnums;
    }

    const enumHandler = (name, items: object[]): string => {
        let lastValue = -1;
        let code = `\r\nexport enum ${name} {`;
        items.forEach((item, index) => {
            if (item['value'] === undefined) {
                item['value'] = lastValue + 1;
            }
            lastValue = item['value'];
            code += `\r\n    ${item['name']} = ${item['value']}`;
            if (index < items.length - 1) {
                code += ','
            }
        })
        code += '\r\n}\r\n';

        return code;
    }

    // Exceptions
    const exceptionsHandler = (values: object[]): string => {
        let exceptions = '';
        Object.keys(values).forEach(key => {
            exceptions += exceptionHandler(key, values[key]);
        })
        return exceptions;
    }

    const exceptionHandler = (name, items: object[]): string => {
        let codes = [];
        codes.push(`\r\nexport class ${name} extends TException {`);
        items.forEach((item, index) => {
            codes.push(`\r\n    ${item['name']}`);
            if (item['option'] === 'optional') {
                codes.push('?');
            }
            codes.push(`: ${valueTypeTransformer(item['type'])};`);
        })
        codes.push('\r\n    name: string;')

        // add constructor
        codes.push('\r\n\r\n    constructor (args?) {');
        codes.push('\r\n        super()');
        codes.push(`\r\n        this.name = "${name}"`);
        items.forEach((item, index) => {
            let value = item['value']
            if (value !== undefined) {
                if (item['type'] === 'string') {
                    value = `"${value}"`
                }
                codes.push(`\r\n        this.${item['name']} = ${value}`)
            }
        })
        codes.push('\r\n        if (args) {');
        items.forEach((item, index) => {
            let paramName = item['name']
            codes.push(`\r\n            if (args.${paramName} !== undefined && args.${paramName} !== null) {\r\n                this.${paramName} = args.${paramName}\r\n            }`);
        })
        codes.push('\r\n        }');
        // close constructor
        codes.push('\r\n    }\r\n');

        // add read function
        codes.push('\r\n    read = (input: IProtocol) => {\r\n        input.readStructBegin()\r\n        while (true) {\r\n            let ret = input.readFieldBegin()\r\n            let fname = ret.fname\r\n            let ftype = ret.ftype\r\n            let fid = ret.fid\r\n            if (ftype === ThriftType.STOP) {\r\n                break\r\n            }\r\n            switch (fid) {');
        items.forEach((item, index) => {
            let type = item['type']
            codes.push(`\r\n                case ${index + 1}:\r\n                    if (ftype === ${getThriftTypeStr(type)}) {\r\n                        this.${item['name']} = ${getReaderStr(type)}\r\n                    } else {\r\n                        input.skip(ftype)\r\n                    }\r\n                    break`)
        })
        codes.push('\r\n                default:\r\n                    input.skip(ftype)\r\n            }\r\n            input.readFieldEnd()\r\n        }\r\n        input.readStructEnd()\r\n        return\r\n    }')

        // add write function
        codes.push(`\r\n\r\n    write = (output: IProtocol) => {\r\n        output.writeStructBegin('${name}')`)
        items.forEach((item, index) => {
            let type = item['type'];
            codes.push(`\r\n        if (this.${item['name']} !== null && this.${item['name']} !== undefined) {\r\n            output.writeFieldBegin('${item["name"]}', ${getThriftTypeStr(type)}, ${index + 1})\r\n            output.${getWriterStr(type)}(this.${item['name']})\r\n            output.writeFieldEnd()\r\n        }`)
        })
        codes.push('\r\n        output.writeFieldStop()\r\n        output.writeStructEnd()\r\n        return\r\n    }')

        // close block
        codes.push('\r\n}\r\n');

        return codes.join('');
    }

    // Structs
    const structsHandler = (values: object[]): string => {
        let structs = '';
        Object.keys(values).forEach(key => {
            structs += structHandler(key, values[key]);
        })
        return structs;
    }

    const structHandler = (name, items: object[]): string => {
        let codes = [];
        codes.push(`\r\nexport class ${name} {`);
        items.forEach((item, index) => {
            codes.push(`\r\n    ${item['name']}`);
            if (item['option'] === 'optional') {
                codes.push('?');
            }
            codes.push(`: ${valueTypeTransformer(item['type'])};`);
        })
        codes.push('\r\n    name: string;')

        // add constructor
        codes.push('\r\n\r\n    constructor (args?) {');
        codes.push(`\r\n        this.name = "${name}"`);
        items.forEach((item, index) => {
            let value = item['value']
            if (value !== undefined) {
                if (item['type'] === 'string') {
                    value = `"${value}"`
                }
                codes.push(`\r\n        this.${item['name']} = ${value}`)
            }
        })
        codes.push('\r\n        if (args) {');
        items.forEach((item, index) => {
            let paramName = item['name']
            codes.push(`\r\n            if (args.${paramName} !== undefined && args.${paramName} !== null) {\r\n                this.${paramName} = args.${paramName}\r\n            }`);
        })
        codes.push('\r\n        }');
        // close constructor
        codes.push('\r\n    }\r\n');

        // add read function
        codes.push('\r\n    read = (input: IProtocol) => {\r\n        input.readStructBegin()\r\n        while (true) {\r\n            let ret = input.readFieldBegin()\r\n            let fname = ret.fname\r\n            let ftype = ret.ftype\r\n            let fid = ret.fid\r\n            if (ftype === ThriftType.STOP) {\r\n                break\r\n            }\r\n            switch (fid) {');
        items.forEach((item, index) => {
            let type = item['type']
            codes.push(`\r\n                case ${index + 1}:\r\n                    if (ftype === ${getThriftTypeStr(type)}) {\r\n                        this.${item['name']} = ${getReaderStr(type)}\r\n                    } else {\r\n                        input.skip(ftype)\r\n                    }\r\n                    break`)
        })
        codes.push('\r\n                default:\r\n                    input.skip(ftype)\r\n            }\r\n            input.readFieldEnd()\r\n        }\r\n        input.readStructEnd()\r\n        return\r\n    }')

        // add write function
        codes.push(`\r\n\r\n    write = (output: IProtocol) => {\r\n        output.writeStructBegin('${name}')`)
        items.forEach((item, index) => {
            let type = item['type'];
            codes.push(`\r\n        if (this.${item['name']} !== null && this.${item['name']} !== undefined) {\r\n            output.writeFieldBegin('${item["name"]}', ${getThriftTypeStr(type)}, ${index + 1})\r\n            output.${getWriterStr(type)}(this.${item['name']})\r\n            output.writeFieldEnd()\r\n        }`)
        })
        codes.push('\r\n        output.writeFieldStop()\r\n        output.writeStructEnd()\r\n        return\r\n    }')

        // close block
        codes.push('\r\n}\r\n');

        return codes.join('');
    }

    const structsLikeHandler = (values: object[]): string => {
        let interfaces = '';
        Object.keys(values).forEach(key => {
            interfaces += structLikeHandler(key, values[key]);
        })
        return interfaces;
    }

    const structLikeHandler = (name, items: object[]): string => {
        let code = `\r\nexport interface ${name} {`;
        items.forEach((item, index) => {
            code += `\r\n    ${item['name']}`;
            if (item['option'] === 'optional') {
                code += '?';
            }
            code += `: ${valueTypeTransformer(item['type'])};`;
        })
        code += '\r\n}\r\n';

        return code;
    }

    const servicesHandler = (services: object[]): string => {
        let code = '';
        Object.keys(services).forEach(key => {
            code += serviceHandler(key, services[key]);
        })
        return code;
    }

    const serviceHandler = (name, service): string => {
        let codes = [];
        let functions = service['functions'];
        codes.push(`\r\nexport class ${name + 'Client'}`)
        if (service['extends']) {
            codes.push(` extends ${service['extends'] + 'Client'}`)
        }
        codes.push(' {\r\n    output: ITransport;\r\n    pClass: ProtocolClass;\r\n    id: number;\r\n    reqs: { [key: string]: any }')

        // constructor block
        codes.push('\r\n\r\n    constructor (output: ITransport, pClass: ProtocolClass) {')
        if (service['extends']) {
            codes.push(`\r\n        super(output, pClass)`)
        }
        codes.push('\r\n        this.output = output\r\n        this.pClass = pClass\r\n        this.id = 0\r\n        this.reqs = {}\r\n    }')

        // function blocks
        Object.keys(functions).forEach(key => {
            let func = functions[key]
            let args = func['args']
            let argStrs = args.map(x => x.name).join(', ')
            // func
            codes.push(`\r\n\r\n    ${key} = (${argStrs ? argStrs + ', callback' : 'callback'}) => {\r\n        if (callback === undefined) {\r\n            let self = this\r\n            return new Promise(function (resolve, reject) {\r\n                self.reqs[self.id] = (err, result) => {\r\n                    if (err) {\r\n                        reject(err)\r\n                    } else {\r\n                        resolve(result)\r\n                    }\r\n                }\r\n                self.send_${key}(${argStrs})\r\n            })\r\n        } else {\r\n            this.reqs[this.id] = callback\r\n            this.send_${key}(${argStrs})\r\n        }\r\n    }`)

            // send_func
            codes.push(`\r\n\r\n    send_${key} = (${argStrs}) => {\r\n        let output = new this.pClass(this.output)\r\n        output.writeMessageBegin('${key}', MessageType.CALL, this.id)\r\n        let args = new ${name}_${key}_args(${argStrs})\r\n        args.write(output)\r\n        output.writeMessageEnd()\r\n        return this.output.flush()\r\n    }`)

            // recv_func
            if (func['oneway'] !== true) {
                codes.push(`\r\n\r\n    recv_${key} = (input, mtype, rseqid) => {\r\n        let callback = this.reqs[rseqid] || function () { }\r\n        delete this.reqs[rseqid]\r\n        if (mtype === MessageType.EXCEPTION) {\r\n        let x = new TApplicationException()\r\n            x.read(input)\r\n            input.readMessageEnd()\r\n            return callback(x)\r\n        }\r\n        let result = new ${name}_${key}_result()\r\n        result.read(input)\r\n        input.readMessageEnd()\r\n`)
                ////// -- throws
                let throws = func['throws']
                throws.forEach((item, index) => {
                    codes.push(`\r\n        if (null !== result.${item['name']}) {\r\n            throw result.${item['name']}\r\n        }`)
                })

                codes.push(`\r\n        if (null !== result.success) {\r\n            return callback(null, result.success)\r\n        }\r\n        return callback('${key} failed: unknown result')\r\n    }`)
            }
        })

        // close class block
        codes.push(`\r\n}`)

        defaultExports.push(name + 'Client');

        return codes.join('');
    }

    const defaultExportsHandler = (): string => {
        let code = '\r\n\r\nexport default {\r\n';
        defaultExports.forEach((v, i) => {
            code += `    ${v}`;
            if (i < defaultExports.length - 1) {
                code += ',';
            }
            code += '\r\n';
        })
        code += '}\r\n';
        return code;
    }

    // include Request
    if (Request && ast.service) {
        code += `import Request from "${Request}";\r\n`
    }

    // includes -> import
    if (ast.include) {
        code += includesHandler(ast.include);
    }

    // const -> const
    if (ast.const) {
        code += constsHandler(ast.const);
    }

    // enum -> interface
    if (ast.enum) {
        code += enumsHandler(ast.enum);
    }

    // exception -> class extends TException
    if (ast.exception) {
        code += exceptionsHandler(ast.exception);
    }

    // struct -> class
    if (ast.struct) {
        code += structsHandler(ast.struct);
    }

    // union -> interface
    if (ast.union) {
        code += structsLikeHandler(ast.union);
    }

    // service -> functions
    if (ast.service) {
        code += servicesHandler(ast.service);
    }

    // default export 
    if (ast.service) {
        code += defaultExportsHandler();
    }

    return code;
}