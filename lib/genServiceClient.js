"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("./helpers");
const thriftTypeMapper = {
    'byte': 'ThriftType.BYTE',
    'i16': 'ThriftType.I16',
    'i32': 'ThriftType.I32',
    'i64': 'ThriftType.I64',
    'double': 'ThriftType.DOUBLE',
    'string': 'ThriftType.STRING',
    'list': 'ThriftType.LIST',
    'set': 'ThriftType.SET',
    'map': 'ThriftType.MAP',
    'struct': 'ThriftType.STRUCT',
    'bool': 'ThriftType.BOOL',
    'void': 'ThriftType.VOID',
    'stop': 'ThriftType.STOP'
};
const fieldReaderMapper = {
    'byte': 'input.readByte()',
    'i16': 'input.readI16()',
    'i32': 'input.readI32()',
    'i64': 'input.readI64()',
    'double': 'input.readDouble()',
    'string': 'input.readString()',
    'bool': 'input.readBool()'
};
const fieldWriterMapper = {
    'byte': 'input.writeByte()',
    'i16': 'input.writeI16()',
    'i32': 'input.writeI32()',
    'i64': 'input.writeI64()',
    'double': 'input.writeDouble()',
    'string': 'input.writeString()',
    'bool': 'input.writeBool()'
};
let header = `/**\r\n * This service client is auto-generated by Thrift2Ts.\r\n *\r\n * ${(new Date()).toString()}\r\n */\r\n\r\n`;
header += `import Thrift from "thrift-browser"\r\n`;
header += `const {\r\n    ThriftType,\r\n    MessageType,\r\n    TApplicationException,\r\n    TException,\r\n    IProtocol\r\n} = Thrift\r\n\r\n`;
exports.default = (ast, Request = './request') => {
    let code = '';
    code += header;
    const defaultExports = [];
    const simplifyType = (type) => {
        if (typeof type === 'string') {
            return type;
        }
        switch (type.name.toLowerCase()) {
            case 'map':
            case 'list':
            case 'set':
                return type;
            default:
                return type.name.toString();
        }
    };
    const mapThriftType = (type) => {
        if (typeof type === 'object') {
            return type.name;
        }
        if (Object.keys(thriftTypeMapper).indexOf(type) > -1) {
            return type;
        }
        if (Object.keys(ast['typedef']).indexOf(type) > -1) {
            return ast['typedef'][type]['type']['name'];
        }
        if (Object.keys(ast['enum']).indexOf(type) > -1) {
            return 'i32';
        }
        if (Object.keys(ast['map']).indexOf(type) > -1) {
            return 'map';
        }
        if (Object.keys(ast['list']).indexOf(type) > -1) {
            return 'list';
        }
        if (Object.keys(ast['set']).indexOf(type) > -1) {
            return 'set';
        }
        if (Object.keys(ast['struct']).indexOf(type) > -1) {
            return 'struct';
        }
        throw new Error(`Unknown thrift type: ${type}`);
    };
    const getThriftTypeStr = (type) => {
        return thriftTypeMapper[mapThriftType(type)];
    };
    const getReaderStr = (type) => {
        return fieldReaderMapper[mapThriftType(type)];
    };
    const getWriterStr = (type) => {
        return fieldWriterMapper[mapThriftType(type)];
    };
    const valueTypeTransformer = (type) => {
        type = simplifyType(type);
        if (typeof type === 'string') {
            switch (type) {
                case 'i16':
                case 'i32':
                case 'i64':
                case 'double':
                    return 'number';
                case 'bool':
                    return 'boolean';
                default:
                    return type;
            }
        }
        switch (type['name']) {
            case 'map':
                return `{[key: ${type['keyType']}]: ${valueTypeTransformer(type['valueType'])}}`;
            case 'list':
            case 'set':
                return `${valueTypeTransformer(type['valueType'])}[]`;
        }
        throw new Error(`Unexpected value type: ${JSON.stringify(type)}`);
    };
    const valueTransformer = (value, isMap = false) => {
        if (typeof value === 'string') {
            return `\"${value}\"`;
        }
        if (['number', 'boolean'].indexOf(typeof value) > -1) {
            return value.toString();
        }
        if (value instanceof Array) {
            if (isMap) {
                return `{${value.map(v => valueTransformer(v)).join(', ')}}`;
            }
            return `[${value.map(v => valueTransformer(v)).join(', ')}]`;
        }
        if (typeof value === 'object' && value['key'] !== undefined && value['value'] !== undefined) {
            return `"${value['key']}": ${valueTransformer(value['value'])}`;
        }
        throw new Error(`Unexpected value: ${JSON.stringify(value)}`);
    };
    const includesHandler = (includes) => {
        let imports = '';
        Object.keys(includes).map(key => includes[key]).forEach(include => {
            imports += `\r\nimport * as ${helpers_1.getThriftFileName(include.value)} from "${helpers_1.thrift2TsPath(include.value)}";\r\n`;
        });
        return imports;
    };
    const constsHandler = (consts) => {
        let newConsts = '';
        Object.keys(consts).forEach(key => {
            newConsts += `\r\nexport const ${key}: ${valueTypeTransformer(consts[key]['type'])} = ${valueTransformer(consts[key]['value'], typeof consts[key]['type'] === 'object' && consts[key]['type']['name'] === 'map')}; \r\n`;
        });
        return newConsts;
    };
    const enumsHandler = (enums) => {
        let newEnums = '';
        Object.keys(enums).forEach(key => {
            newEnums += enumHandler(key, enums[key]['items']);
        });
        return newEnums;
    };
    const enumHandler = (name, items) => {
        let lastValue = -1;
        let code = `\r\nexport enum ${name} {`;
        items.forEach((item, index) => {
            if (item['value'] === undefined) {
                item['value'] = lastValue + 1;
            }
            lastValue = item['value'];
            code += `\r\n    ${item['name']} = ${item['value']}`;
            if (index < items.length - 1) {
                code += ',';
            }
        });
        code += '\r\n}\r\n';
        return code;
    };
    const exceptionsHandler = (values) => {
        let exceptions = '';
        Object.keys(values).forEach(key => {
            exceptions += exceptionHandler(key, values[key]);
        });
        return exceptions;
    };
    const exceptionHandler = (name, items) => {
        let codes = [];
        codes.push(`\r\nexport class ${name} extends TException {`);
        items.forEach((item, index) => {
            codes.push(`\r\n    ${item['name']}`);
            if (item['option'] === 'optional') {
                codes.push('?');
            }
            codes.push(`: ${valueTypeTransformer(item['type'])};`);
        });
        codes.push('\r\n    name: string;');
        codes.push('\r\n\r\n    constructor (args?) {');
        codes.push('\r\n        super()');
        codes.push(`\r\n        this.name = "${name}"`);
        items.forEach((item, index) => {
            let value = item['value'];
            if (value !== undefined) {
                if (item['type'] === 'string') {
                    value = `"${value}"`;
                }
                codes.push(`\r\n        this.${item['name']} = ${value}`);
            }
        });
        codes.push('\r\n        if (args) {');
        items.forEach((item, index) => {
            let paramName = item['name'];
            codes.push(`\r\n            if (args.${paramName} !== undefined && args.${paramName} !== null) {\r\n                this.${paramName} = args.${paramName}\r\n            }`);
        });
        codes.push('\r\n        }');
        codes.push('\r\n    }\r\n');
        codes.push('\r\n    read = (input: IProtocol) => {\r\n        input.readStructBegin()\r\n        while (true) {\r\n            let ret = input.readFieldBegin()\r\n            let fname = ret.fname\r\n            let ftype = ret.ftype\r\n            let fid = ret.fid\r\n            if (ftype === ThriftType.STOP) {\r\n                break\r\n            }\r\n            switch (fid) {');
        items.forEach((item, index) => {
            let type = item['type'];
            codes.push(`\r\n                case ${index + 1}:\r\n                    if (ftype === ${getThriftTypeStr(type)}) {\r\n                        this.${item['name']} = ${getReaderStr(type)}\r\n                    } else {\r\n                        input.skip(ftype)\r\n                    }\r\n                    break`);
        });
        codes.push('\r\n                default:\r\n                    input.skip(ftype)\r\n            }\r\n            input.readFieldEnd()\r\n        }\r\n        input.readStructEnd()\r\n        return\r\n    }');
        codes.push(`\r\n\r\n    write = (output: IProtocol) => {\r\n        output.writeStructBegin('${name}')`);
        items.forEach((item, index) => {
            let type = item['type'];
            codes.push(`\r\n        if (this.${item['name']} !== null && this.${item['name']} !== undefined) {\r\n            output.writeFieldBegin('${item["name"]}', ${getThriftTypeStr(type)}, ${index + 1})\r\n            output.${getWriterStr(type)}(this.${item['name']})\r\n            output.writeFieldEnd()\r\n        }`);
        });
        codes.push('\r\n        output.writeFieldStop()\r\n        output.writeStructEnd()\r\n        return\r\n    }');
        codes.push('\r\n}\r\n');
        return codes.join('');
    };
    const structsHandler = (values) => {
        let structs = '';
        Object.keys(values).forEach(key => {
            structs += structHandler(key, values[key]);
        });
        return structs;
    };
    const structHandler = (name, items) => {
        let codes = [];
        codes.push(`\r\nexport class ${name} {`);
        items.forEach((item, index) => {
            codes.push(`\r\n    ${item['name']}`);
            if (item['option'] === 'optional') {
                codes.push('?');
            }
            codes.push(`: ${valueTypeTransformer(item['type'])};`);
        });
        codes.push('\r\n    name: string;');
        codes.push('\r\n\r\n    constructor (args?) {');
        codes.push(`\r\n        this.name = "${name}"`);
        items.forEach((item, index) => {
            let value = item['value'];
            if (value !== undefined) {
                if (item['type'] === 'string') {
                    value = `"${value}"`;
                }
                codes.push(`\r\n        this.${item['name']} = ${value}`);
            }
        });
        codes.push('\r\n        if (args) {');
        items.forEach((item, index) => {
            let paramName = item['name'];
            codes.push(`\r\n            if (args.${paramName} !== undefined && args.${paramName} !== null) {\r\n                this.${paramName} = args.${paramName}\r\n            }`);
        });
        codes.push('\r\n        }');
        codes.push('\r\n    }\r\n');
        codes.push('\r\n    read = (input: IProtocol) => {\r\n        input.readStructBegin()\r\n        while (true) {\r\n            let ret = input.readFieldBegin()\r\n            let fname = ret.fname\r\n            let ftype = ret.ftype\r\n            let fid = ret.fid\r\n            if (ftype === ThriftType.STOP) {\r\n                break\r\n            }\r\n            switch (fid) {');
        items.forEach((item, index) => {
            let type = item['type'];
            codes.push(`\r\n                case ${index + 1}:\r\n                    if (ftype === ${getThriftTypeStr(type)}) {\r\n                        this.${item['name']} = ${getReaderStr(type)}\r\n                    } else {\r\n                        input.skip(ftype)\r\n                    }\r\n                    break`);
        });
        codes.push('\r\n                default:\r\n                    input.skip(ftype)\r\n            }\r\n            input.readFieldEnd()\r\n        }\r\n        input.readStructEnd()\r\n        return\r\n    }');
        codes.push(`\r\n\r\n    write = (output: IProtocol) => {\r\n        output.writeStructBegin('${name}')`);
        items.forEach((item, index) => {
            let type = item['type'];
            codes.push(`\r\n        if (this.${item['name']} !== null && this.${item['name']} !== undefined) {\r\n            output.writeFieldBegin('${item["name"]}', ${getThriftTypeStr(type)}, ${index + 1})\r\n            output.${getWriterStr(type)}(this.${item['name']})\r\n            output.writeFieldEnd()\r\n        }`);
        });
        codes.push('\r\n        output.writeFieldStop()\r\n        output.writeStructEnd()\r\n        return\r\n    }');
        codes.push('\r\n}\r\n');
        return codes.join('');
    };
    const structsLikeHandler = (values) => {
        let interfaces = '';
        Object.keys(values).forEach(key => {
            interfaces += structLikeHandler(key, values[key]);
        });
        return interfaces;
    };
    const structLikeHandler = (name, items) => {
        let code = `\r\nexport interface ${name} {`;
        items.forEach((item, index) => {
            code += `\r\n    ${item['name']}`;
            if (item['option'] === 'optional') {
                code += '?';
            }
            code += `: ${valueTypeTransformer(item['type'])};`;
        });
        code += '\r\n}\r\n';
        return code;
    };
    const servicesHandler = (services) => {
        let code = '';
        Object.keys(services).forEach(key => {
            code += serviceHandler(key, services[key]);
        });
        return code;
    };
    const serviceHandler = (name, service) => {
        let code = '';
        let functions = service['functions'];
        Object.keys(functions).forEach(key => {
            code += serviceFunctionHandler(name, functions[key]);
        });
        return code;
    };
    const serviceFunctionHandler = (name, serviceFunc) => {
        let code = '';
        const method = `${name}.${serviceFunc['name']}`;
        const returnType = valueTypeTransformer(serviceFunc['type']);
        let args = serviceFunc['args'];
        let argNames = [];
        let argNameAndTypes = [];
        args.forEach(arg => {
            argNames.push(arg['name']);
            argNameAndTypes.push(`${arg['name']}: ${valueTypeTransformer(arg['type'])}`);
        });
        code += `\r\nexport function ${serviceFunc['name']}(${argNameAndTypes.join(', ')}): Promise<${returnType}> {\r\n`;
        code += `    return Request<${returnType}>("${method}", { ${argNames.join(', ')} })`;
        code += '\r\n}\r\n';
        defaultExports.push(serviceFunc['name']);
        return code;
    };
    const defaultExportsHandler = () => {
        let code = '\r\n\r\nexport default {\r\n';
        defaultExports.forEach((v, i) => {
            code += `    ${v}`;
            if (i < defaultExports.length - 1) {
                code += ',';
            }
            code += '\r\n';
        });
        code += '}\r\n';
        return code;
    };
    if (Request && ast.service) {
        code += `import Request from "${Request}";\r\n`;
    }
    if (ast.include) {
        code += includesHandler(ast.include);
    }
    if (ast.const) {
        code += constsHandler(ast.const);
    }
    if (ast.enum) {
        code += enumsHandler(ast.enum);
    }
    if (ast.exception) {
        code += exceptionsHandler(ast.exception);
    }
    if (ast.struct) {
        code += structsHandler(ast.struct);
    }
    if (ast.union) {
        code += structsLikeHandler(ast.union);
    }
    if (ast.service) {
        code += servicesHandler(ast.service);
    }
    if (ast.service) {
        code += defaultExportsHandler();
    }
    return code;
};
