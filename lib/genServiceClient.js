"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("./helpers");
const thriftTypeMapper = {
    'byte': 'ThriftType.BYTE',
    'i16': 'ThriftType.I16',
    'i32': 'ThriftType.I32',
    'i64': 'ThriftType.I64',
    'double': 'ThriftType.DOUBLE',
    'string': 'ThriftType.STRING',
    'list': 'ThriftType.LIST',
    'set': 'ThriftType.SET',
    'map': 'ThriftType.MAP',
    'struct': 'ThriftType.STRUCT',
    'bool': 'ThriftType.BOOL',
    'void': 'ThriftType.VOID',
    'stop': 'ThriftType.STOP'
};
const fieldReaderMapper = {
    'byte': 'readByte()',
    'i16': 'readI16()',
    'i32': 'readI32()',
    'i64': 'readI64()',
    'double': 'readDouble()',
    'string': 'readString()',
    'bool': 'readBool()'
};
const fieldWriterMapper = {
    'byte': 'writeByte',
    'i16': 'writeI16',
    'i32': 'writeI32',
    'i64': 'writeI64',
    'double': 'writeDouble',
    'string': 'writeString',
    'bool': 'writeBool'
};
const SPACE_4 = "    ";
const R_SPACE_4 = "\r\n" + SPACE_4;
const R_SPACE_8 = "\r\n" + SPACE_4.repeat(2);
const R_SPACE_12 = "\r\n" + SPACE_4.repeat(3);
const R_SPACE_16 = "\r\n" + SPACE_4.repeat(4);
const R_SPACE_20 = "\r\n" + SPACE_4.repeat(5);
const R_SPACE_24 = "\r\n" + SPACE_4.repeat(6);
let header = `/**\r\n * This service client is auto-generated by Thrift2Ts.\r\n *\r\n * ${(new Date()).toString()}\r\n */\r\n\r\n`;
header += `import Thrift from "thrift-browser"\r\n`;
header += `const {${R_SPACE_4}ThriftType,${R_SPACE_4}MessageType,${R_SPACE_4}TApplicationException,${R_SPACE_4}TException,${R_SPACE_4}IProtocol,${R_SPACE_4}ProtocolClass,${R_SPACE_4}ITransport,${R_SPACE_4}TransportClass\r\n} = Thrift\r\n\r\n`;
exports.default = (ast, Request = './request') => {
    let code = '';
    code += header;
    const defaultExports = [];
    const simplifyType = (type) => {
        if (typeof type === 'string') {
            return type;
        }
        switch (type.name.toLowerCase()) {
            case 'map':
            case 'list':
            case 'set':
                return type;
            default:
                return type.name.toString();
        }
    };
    const mapThriftType = (type) => {
        if (typeof type === 'object') {
            return type.name;
        }
        if (Object.keys(thriftTypeMapper).indexOf(type) > -1) {
            return type;
        }
        if (ast['typedef'] && Object.keys(ast['typedef']).indexOf(type) > -1) {
            return ast['typedef'][type]['type']['name'];
        }
        if (ast['enum'] && Object.keys(ast['enum']).indexOf(type) > -1) {
            return 'i32';
        }
        if (ast['map'] && Object.keys(ast['map']).indexOf(type) > -1) {
            return 'map';
        }
        if (ast['list'] && Object.keys(ast['list']).indexOf(type) > -1) {
            return 'list';
        }
        if (ast['set'] && Object.keys(ast['set']).indexOf(type) > -1) {
            return 'set';
        }
        if (ast['struct'] && Object.keys(ast['struct']).indexOf(type) > -1) {
            return 'struct';
        }
        if (ast['exception'] && Object.keys(ast['exception']).indexOf(type) > -1) {
            return 'struct';
        }
        throw new Error(`Unknown thrift type: ${type}`);
    };
    const getThriftTypeStr = (type) => {
        return thriftTypeMapper[mapThriftType(type)];
    };
    const getReaderStr = (type) => {
        return fieldReaderMapper[mapThriftType(type)];
    };
    const getWriterStr = (type) => {
        return fieldWriterMapper[mapThriftType(type)];
    };
    const valueTypeTransformer = (type) => {
        type = simplifyType(type);
        if (typeof type === 'string') {
            switch (type) {
                case 'i16':
                case 'i32':
                case 'i64':
                case 'double':
                    return 'number';
                case 'bool':
                    return 'boolean';
                default:
                    return type;
            }
        }
        switch (type['name']) {
            case 'map':
                return `{[key: ${type['keyType']}]: ${valueTypeTransformer(type['valueType'])}}`;
            case 'list':
            case 'set':
                return `${valueTypeTransformer(type['valueType'])}[]`;
        }
        throw new Error(`Unexpected value type: ${JSON.stringify(type)}`);
    };
    const valueTransformer = (value, isMap = false) => {
        if (typeof value === 'string') {
            return `\"${value}\"`;
        }
        if (['number', 'boolean'].indexOf(typeof value) > -1) {
            return value.toString();
        }
        if (value instanceof Array) {
            if (isMap) {
                return `{${value.map(v => valueTransformer(v)).join(', ')}}`;
            }
            return `[${value.map(v => valueTransformer(v)).join(', ')}]`;
        }
        if (typeof value === 'object' && value['key'] !== undefined && value['value'] !== undefined) {
            return `"${value['key']}": ${valueTransformer(value['value'])}`;
        }
        throw new Error(`Unexpected value: ${JSON.stringify(value)}`);
    };
    const includesHandler = (includes) => {
        let imports = [];
        Object.keys(includes).map(key => includes[key]).forEach(include => {
            imports.push(`\r\nimport * as ${helpers_1.getThriftFileName(include.value)} from "${helpers_1.thrift2TsPath(include.value)}";\r\n`);
        });
        return imports.join('');
    };
    const constsHandler = (consts) => {
        let newConsts = [];
        Object.keys(consts).forEach(key => {
            newConsts.push(`\r\nexport const ${key}: ${valueTypeTransformer(consts[key]['type'])} = ${valueTransformer(consts[key]['value'], typeof consts[key]['type'] === 'object' && consts[key]['type']['name'] === 'map')}; \r\n`);
        });
        return newConsts.join('');
    };
    const enumsHandler = (enums) => {
        let newEnums = [];
        Object.keys(enums).forEach(key => {
            newEnums.push(enumHandler(key, enums[key]['items']));
        });
        return newEnums.join('');
    };
    const enumHandler = (name, items) => {
        let lastValue = -1;
        let codes = [`\r\nexport enum ${name} {`];
        items.forEach((item, index) => {
            if (item['value'] === undefined) {
                item['value'] = lastValue + 1;
            }
            lastValue = item['value'];
            codes.push(`${R_SPACE_4}${item['name']} = ${item['value']}`);
            if (index < items.length - 1) {
                codes.push(',');
            }
        });
        codes.push('\r\n}\r\n');
        return codes.join('');
    };
    const exceptionsHandler = (values) => {
        let exceptions = [];
        Object.keys(values).forEach(key => {
            exceptions.push(exceptionHandler(key, values[key]));
        });
        return exceptions.join('');
    };
    const exceptionHandler = (name, items) => {
        let codes = [];
        codes.push(`\r\nexport class ${name} extends TException {`);
        items.forEach((item, index) => {
            codes.push(`${R_SPACE_4}${item['name']}`);
            if (item['option'] === 'optional') {
                codes.push('?');
            }
            codes.push(`: ${valueTypeTransformer(item['type'])};`);
        });
        codes.push(`${R_SPACE_4}name: string;`);
        codes.push(`\r\n${R_SPACE_4}constructor (args?) {`);
        codes.push(`${R_SPACE_8}super()`);
        codes.push(`${R_SPACE_8}this.name = "${name}"`);
        items.forEach((item, index) => {
            let value = item['value'];
            if (value !== undefined) {
                if (item['type'] === 'string') {
                    value = `"${value}"`;
                }
                codes.push(`${R_SPACE_8}this.${item['name']} = ${value}`);
            }
            else {
                codes.push(`${R_SPACE_8}this.${item['name']} = null`);
            }
        });
        codes.push('${R_SPACE_8}if (args) {');
        items.forEach((item, index) => {
            let paramName = item['name'];
            codes.push(`${R_SPACE_12}if (args.${paramName} !== undefined && args.${paramName} !== null) {${R_SPACE_16}this.${paramName} = args.${paramName}${R_SPACE_12}}`);
        });
        codes.push(`${R_SPACE_8}}`);
        codes.push(`${R_SPACE_4}}\r\n`);
        codes.push(`${R_SPACE_4}read = (input: IProtocol) => {${R_SPACE_8}input.readStructBegin()${R_SPACE_8}while (true) {${R_SPACE_12}let ret = input.readFieldBegin()${R_SPACE_12}let fname = ret.fname${R_SPACE_12}let ftype = ret.ftype${R_SPACE_12}let fid = ret.fid${R_SPACE_12}if (ftype === ThriftType.STOP) {${R_SPACE_16}break${R_SPACE_12}}${R_SPACE_12}switch (fid) {`);
        items.forEach((item, index) => {
            let type = item['type'];
            codes.push(`${R_SPACE_16}case ${index + 1}:${R_SPACE_20}if (ftype === ${getThriftTypeStr(type)}) {${R_SPACE_24}this.${item['name']} = input.${getReaderStr(type)}${R_SPACE_20}} else {${R_SPACE_24}input.skip(ftype)${R_SPACE_20}}${R_SPACE_20}break`);
        });
        codes.push(`${R_SPACE_16}default:${R_SPACE_20}input.skip(ftype)${R_SPACE_12}}${R_SPACE_12}input.readFieldEnd()${R_SPACE_8}}${R_SPACE_8}input.readStructEnd()${R_SPACE_8}return${R_SPACE_4}}`);
        codes.push(`\r\n${R_SPACE_4}write = (output: IProtocol) => {${R_SPACE_8}output.writeStructBegin('${name}')`);
        items.forEach((item, index) => {
            let type = item['type'];
            codes.push(`${R_SPACE_8}if (this.${item['name']} !== null && this.${item['name']} !== undefined) {${R_SPACE_12}output.writeFieldBegin('${item["name"]}', ${getThriftTypeStr(type)}, ${index + 1})${R_SPACE_12}output.${getWriterStr(type)}(this.${item['name']})${R_SPACE_12}output.writeFieldEnd()${R_SPACE_8}}`);
        });
        codes.push(`${R_SPACE_8}output.writeFieldStop()${R_SPACE_8}output.writeStructEnd()${R_SPACE_8}return${R_SPACE_4}}`);
        codes.push('\r\n}\r\n');
        return codes.join('');
    };
    const structsHandler = (values) => {
        let structs = [];
        Object.keys(values).forEach(key => {
            structs.push(structHandler(key, values[key]));
        });
        return structs.join('');
    };
    const structHandler = (name, items) => {
        let codes = [];
        codes.push(`\r\nexport class ${name} {`);
        items.forEach((item, index) => {
            codes.push(`${R_SPACE_4}${item['name']}`);
            if (item['option'] === 'optional') {
                codes.push('?');
            }
            codes.push(`: ${valueTypeTransformer(item['type'])};`);
        });
        codes.push(`${R_SPACE_4}name: string;`);
        codes.push(`\r\n${R_SPACE_4}constructor (args?) {`);
        codes.push(`${R_SPACE_8}this.name = "${name}"`);
        items.forEach((item, index) => {
            let value = item['value'];
            if (value !== undefined) {
                if (item['type'] === 'string') {
                    value = `"${value}"`;
                }
                codes.push(`${R_SPACE_8}this.${item['name']} = ${value}`);
            }
            else {
                codes.push(`${R_SPACE_8}this.${item['name']} = null`);
            }
        });
        codes.push(`${R_SPACE_8}if (args) {`);
        items.forEach((item, index) => {
            let paramName = item['name'];
            codes.push(`${R_SPACE_12}if (args.${paramName} !== undefined && args.${paramName} !== null) {${R_SPACE_16}this.${paramName} = args.${paramName}${R_SPACE_12}}`);
        });
        codes.push(`${R_SPACE_8}}`);
        codes.push(`${R_SPACE_4}}\r\n`);
        codes.push(`${R_SPACE_4}read = (input: IProtocol) => {${R_SPACE_8}input.readStructBegin()${R_SPACE_8}while (true) {${R_SPACE_12}let ret = input.readFieldBegin()${R_SPACE_12}let fname = ret.fname${R_SPACE_12}let ftype = ret.ftype${R_SPACE_12}let fid = ret.fid${R_SPACE_12}if (ftype === ThriftType.STOP) {${R_SPACE_16}break${R_SPACE_12}}${R_SPACE_12}switch (fid) {`);
        items.forEach((item, index) => {
            let type = item['type'];
            codes.push(`${R_SPACE_16}case ${index + 1}:${R_SPACE_20}if (ftype === ${getThriftTypeStr(type)}) {${R_SPACE_24}this.${item['name']} = input.${getReaderStr(type)}${R_SPACE_20}} else {${R_SPACE_24}input.skip(ftype)${R_SPACE_20}}${R_SPACE_20}break`);
        });
        codes.push(`${R_SPACE_16}default:${R_SPACE_20}input.skip(ftype)${R_SPACE_12}}${R_SPACE_12}input.readFieldEnd()${R_SPACE_8}}${R_SPACE_8}input.readStructEnd()${R_SPACE_8}return${R_SPACE_4}}`);
        codes.push(`\r\n${R_SPACE_4}write = (output: IProtocol) => {${R_SPACE_8}output.writeStructBegin('${name}')`);
        items.forEach((item, index) => {
            let type = item['type'];
            codes.push(`${R_SPACE_8}if (this.${item['name']} !== null && this.${item['name']} !== undefined) {${R_SPACE_12}output.writeFieldBegin('${item["name"]}', ${getThriftTypeStr(type)}, ${index + 1})${R_SPACE_12}output.${getWriterStr(type)}(this.${item['name']})${R_SPACE_12}output.writeFieldEnd()${R_SPACE_8}}`);
        });
        codes.push(`${R_SPACE_8}output.writeFieldStop()${R_SPACE_8}output.writeStructEnd()${R_SPACE_8}return${R_SPACE_4}}`);
        codes.push('\r\n}\r\n');
        return codes.join('');
    };
    const structsLikeHandler = (values) => {
        let interfaces = [];
        Object.keys(values).forEach(key => {
            interfaces.push(structLikeHandler(key, values[key]));
        });
        return interfaces.join('');
    };
    const structLikeHandler = (name, items) => {
        let codes = [`\r\nexport interface ${name} {`];
        items.forEach((item, index) => {
            codes.push(`${R_SPACE_4}${item['name']}`);
            if (item['option'] === 'optional') {
                codes.push('?');
            }
            codes.push(`: ${valueTypeTransformer(item['type'])};`);
        });
        codes.push('\r\n}\r\n');
        return codes.join('');
    };
    const servicesHandler = (services) => {
        let codes = [];
        Object.keys(services).forEach(key => {
            codes.push(serviceArgsndResultsHandler(key, services[key]));
            codes.push(serviceHandler(key, services[key]));
        });
        return codes.join('');
    };
    const serviceArgsndResultsHandler = (name, service) => {
        let codes = [];
        let functions = service['functions'];
        Object.keys(functions).forEach(key => {
            let func = functions[key];
            codes.push(serviceArgHandler(name, func));
            codes.push(serviceResultHandler(name, func));
        });
        return codes.join('');
    };
    const serviceArgHandler = (service, func) => {
        let codes = [];
        let args = func['args'];
        let name = `${service}_${func['name']}_args`;
        codes.push(`\r\nexport class ${name} {`);
        args.forEach((arg, index) => {
            codes.push(`${R_SPACE_4}${arg['name']}`);
            if (arg['option'] === 'optional') {
                codes.push('?');
            }
            codes.push(`: ${valueTypeTransformer(arg['type'])};`);
        });
        codes.push(`${R_SPACE_4}name: string;`);
        codes.push(`\r\n${R_SPACE_4}constructor (args?) {`);
        codes.push(`${R_SPACE_8}this.name = "${name}"`);
        args.forEach((arg, index) => {
            let value = arg['value'];
            if (value !== undefined) {
                if (arg['type'] === 'string') {
                    value = `"${value}"`;
                }
                codes.push(`${R_SPACE_8}this.${arg['name']} = ${value}`);
            }
            else {
                codes.push(`${R_SPACE_8}this.${arg['name']} = null`);
            }
        });
        if (args && args.length) {
            codes.push('${R_SPACE_8}if (args) {');
            args.forEach((item, index) => {
                let paramName = item['name'];
                let value = `args.${paramName}`;
                if (mapThriftType(item['type']) === 'struct') {
                    value = `new ${item['type']}(${value})`;
                }
                codes.push(`${R_SPACE_12}if (args.${paramName} !== undefined && args.${paramName} !== null) {${R_SPACE_16}this.${paramName} = ${value}${R_SPACE_12}}`);
            });
            codes.push(`${R_SPACE_8}}`);
        }
        codes.push(`${R_SPACE_4}}\r\n`);
        codes.push(`${R_SPACE_4}read = (input: IProtocol) => {${R_SPACE_8}input.readStructBegin()${R_SPACE_8}while (true) {${R_SPACE_12}let ret = input.readFieldBegin()${R_SPACE_12}let fname = ret.fname${R_SPACE_12}let ftype = ret.ftype${R_SPACE_12}let fid = ret.fid${R_SPACE_12}if (ftype === ThriftType.STOP) {${R_SPACE_16}break${R_SPACE_12}}`);
        if (args && args.length) {
            codes.push(`${R_SPACE_12}switch (fid) {`);
            args.forEach((item, index) => {
                let type = item['type'];
                codes.push(`${R_SPACE_16}case ${index + 1}:${R_SPACE_20}if (ftype === ${getThriftTypeStr(type)}) {${R_SPACE_24}`);
                if (mapThriftType(type) === 'struct') {
                    codes.push(`this.${item['name']} = new ${type}()${R_SPACE_24}this.${item['name']}.read(input)`);
                }
                else {
                    codes.push(`this.${item['name']} = input.${getReaderStr(type)}`);
                }
                codes.push(`${R_SPACE_20}} else {${R_SPACE_24}input.skip(ftype)${R_SPACE_20}}${R_SPACE_20}break`);
            });
            codes.push(`${R_SPACE_16}default:${R_SPACE_20}input.skip(ftype)${R_SPACE_12}}`);
        }
        else {
            codes.push(`${R_SPACE_12}input.skip(ftype)`);
        }
        codes.push(`${R_SPACE_12}input.readFieldEnd()${R_SPACE_8}}${R_SPACE_8}input.readStructEnd()${R_SPACE_8}return${R_SPACE_4}}`);
        codes.push(`\r\n${R_SPACE_4}write = (output: IProtocol) => {${R_SPACE_8}output.writeStructBegin('${name}')`);
        args.forEach((item, index) => {
            let type = item['type'];
            codes.push(`${R_SPACE_8}if (this.${item['name']} !== null && this.${item['name']} !== undefined) {${R_SPACE_12}output.writeFieldBegin('${item["name"]}', ${getThriftTypeStr(type)}, ${index + 1})${R_SPACE_12}`);
            if (mapThriftType(type) === 'struct') {
                codes.push(`this.${item['name']}.write(output)`);
            }
            else {
                codes.push(`output.${getWriterStr(type)}(this.${item['name']})`);
            }
            codes.push(`${R_SPACE_12}output.writeFieldEnd()${R_SPACE_8}}`);
        });
        codes.push(`${R_SPACE_8}output.writeFieldStop()${R_SPACE_8}output.writeStructEnd()${R_SPACE_8}return${R_SPACE_4}}`);
        codes.push('\r\n}\r\n');
        return codes.join('');
    };
    const serviceResultHandler = (service, func) => {
        let codes = [];
        let throws = func['throws'];
        let name = `${service}_${func['name']}_result`;
        codes.push(`\r\nexport class ${name} {`);
        codes.push(`${R_SPACE_4}name: string;`);
        codes.push(`${R_SPACE_4}success: any;`);
        if (throws && throws.length) {
            throws.forEach((item, index) => {
                codes.push(`${R_SPACE_4}${item['name']}: ${item['type']};`);
            });
        }
        codes.push(`\r\n${R_SPACE_4}constructor (args?) {`);
        codes.push(`${R_SPACE_8}this.name = "${name}"`);
        if (func['type'] !== 'void') {
            codes.push(`${R_SPACE_8}this.success = null`);
            throws.forEach((item, index) => {
                codes.push(`${R_SPACE_8}this.${item['name']} = null`);
            });
            throws.forEach((item, index) => {
                codes.push(`${R_SPACE_8}if (args instanceof ${item['type']}) {${R_SPACE_12}this.${item['name']} = args${R_SPACE_12}return${R_SPACE_8}}`);
            });
            codes.push(`${R_SPACE_8}if (args) {`);
            codes.push(`${R_SPACE_12}if (args.success !== undefined && args.success !== null) {${R_SPACE_16}this.success = args.success${R_SPACE_12}}`);
            throws.forEach((item, index) => {
                codes.push(`${R_SPACE_12}if (args.${item['name']} !== undefined && args.${item['name']} !== null) {${R_SPACE_16}this.${item['name']} = args.${item['name']}${R_SPACE_12}}`);
            });
            codes.push(`${R_SPACE_8}}`);
        }
        codes.push(`${R_SPACE_4}}\r\n`);
        codes.push(`${R_SPACE_4}read = (input: IProtocol) => {${R_SPACE_8}input.readStructBegin()${R_SPACE_8}while (true) {${R_SPACE_12}let ret = input.readFieldBegin()${R_SPACE_12}let fname = ret.fname${R_SPACE_12}let ftype = ret.ftype${R_SPACE_12}let fid = ret.fid${R_SPACE_12}if (ftype === ThriftType.STOP) {${R_SPACE_16}break${R_SPACE_12}}`);
        if (func['type'] !== 'void') {
            codes.push(`${R_SPACE_12}switch (fid) {`);
            codes.push(`${R_SPACE_16}case 0:${R_SPACE_20}if (ftype === ${getThriftTypeStr(func['type'])}) {${R_SPACE_24}this.success = input.${getReaderStr(func['type'])}${R_SPACE_20}} else {${R_SPACE_24}input.skip(ftype)${R_SPACE_20}}${R_SPACE_20}break`);
            if (throws && throws.length) {
                throws.forEach((item, index) => {
                    codes.push(`${R_SPACE_16}case ${index + 1}:${R_SPACE_20}if (ftype === ${getThriftTypeStr(item['type'])}) {${R_SPACE_24}this.${item['name']} = new ${item['type']}()${R_SPACE_24}this.${item['name']}.read(input)${R_SPACE_20}} else {${R_SPACE_24}input.skip(ftype)${R_SPACE_20}}${R_SPACE_20}break`);
                });
            }
            codes.push(`${R_SPACE_16}default:${R_SPACE_20}input.skip(ftype)${R_SPACE_12}}`);
        }
        else {
            codes.push(`${R_SPACE_12}input.skip(ftype)`);
        }
        codes.push(`${R_SPACE_12}input.readFieldEnd()${R_SPACE_8}}${R_SPACE_8}input.readStructEnd()${R_SPACE_8}return${R_SPACE_4}}`);
        codes.push(`\r\n${R_SPACE_4}write = (output: IProtocol) => {${R_SPACE_8}output.writeStructBegin('${name}')`);
        if (func['type'] !== 'void') {
            codes.push(`${R_SPACE_8}if (this.success !== null && this.success !== undefined) {${R_SPACE_12}output.writeFieldBegin('success', ${getThriftTypeStr(func['type'])}, 0)${R_SPACE_12}output.${getWriterStr(func['type'])}(this.success)${R_SPACE_12}output.writeFieldEnd()${R_SPACE_8}}`);
        }
        if (throws && throws.length) {
            throws.forEach((item, index) => {
                codes.push(`${R_SPACE_8}if (this.${item['name']} !== null && this.${item['name']} !== undefined) {${R_SPACE_12}output.writeFieldBegin('${item['name']}', ${getThriftTypeStr(item['type'])}, ${index + 1})${R_SPACE_12}this.${item['name']}.write(output)${R_SPACE_12}output.writeFieldEnd()${R_SPACE_8}}`);
            });
        }
        codes.push(`${R_SPACE_8}output.writeFieldStop()${R_SPACE_8}output.writeStructEnd()${R_SPACE_8}return${R_SPACE_4}}`);
        codes.push('\r\n}\r\n');
        return codes.join('');
    };
    const serviceHandler = (name, service) => {
        let codes = [];
        let functions = service['functions'];
        codes.push(`\r\nexport class ${name + 'Client'}`);
        if (service['extends']) {
            codes.push(` extends ${service['extends'] + 'Client'}`);
        }
        codes.push(` {${R_SPACE_4}output: ITransport;${R_SPACE_4}pClass: ProtocolClass;${R_SPACE_4}id: number;${R_SPACE_4}reqs: { [key: string]: any }`);
        codes.push(`\r\n${R_SPACE_4}constructor (output: ITransport, pClass: ProtocolClass) {`);
        if (service['extends']) {
            codes.push(`${R_SPACE_8}super(output, pClass)`);
        }
        codes.push(`${R_SPACE_8}this.output = output${R_SPACE_8}this.pClass = pClass${R_SPACE_8}this.id = 0${R_SPACE_8}this.reqs = {}${R_SPACE_4}}`);
        Object.keys(functions).forEach(key => {
            let func = functions[key];
            let args = func['args'];
            let argStrs = args.map(x => x.name).join(', ');
            codes.push(`\r\n${R_SPACE_4}${key} = (${argStrs ? argStrs + ', callback' : 'callback'}) => {${R_SPACE_8}if (callback === undefined) {${R_SPACE_12}let self = this${R_SPACE_12}return new Promise(function (resolve, reject) {${R_SPACE_16}self.reqs[self.id] = (err, result) => {${R_SPACE_20}if (err) {${R_SPACE_24}reject(err)${R_SPACE_20}} else {${R_SPACE_24}resolve(result)${R_SPACE_20}}${R_SPACE_16}}${R_SPACE_16}self.send_${key}(${argStrs})${R_SPACE_12}})${R_SPACE_8}} else {${R_SPACE_12}this.reqs[this.id] = callback${R_SPACE_12}this.send_${key}(${argStrs})${R_SPACE_8}}${R_SPACE_4}}`);
            codes.push(`\r\n${R_SPACE_4}send_${key} = (${argStrs}) => {${R_SPACE_8}let output = new this.pClass(this.output)${R_SPACE_8}output.writeMessageBegin('${key}', MessageType.CALL, this.id)${R_SPACE_8}let args = new ${name}_${key}_args({${argStrs}})${R_SPACE_8}args.write(output)${R_SPACE_8}output.writeMessageEnd()${R_SPACE_8}return this.output.flush()${R_SPACE_4}}`);
            if (func['oneway'] !== true) {
                codes.push(`\r\n${R_SPACE_4}recv_${key} = (input, mtype, rseqid) => {${R_SPACE_8}let callback = this.reqs[rseqid] || function () { }${R_SPACE_8}delete this.reqs[rseqid]${R_SPACE_8}if (mtype === MessageType.EXCEPTION) {${R_SPACE_8}let x = new TApplicationException()${R_SPACE_12}x.read(input)${R_SPACE_12}input.readMessageEnd()${R_SPACE_12}return callback(x)${R_SPACE_8}}${R_SPACE_8}let result = new ${name}_${key}_result()${R_SPACE_8}result.read(input)${R_SPACE_8}input.readMessageEnd()\r\n`);
                let throws = func['throws'];
                throws.forEach((item, index) => {
                    codes.push(`${R_SPACE_8}if (null !== result.${item['name']}) {${R_SPACE_12}throw result.${item['name']}${R_SPACE_8}}`);
                });
                codes.push(`${R_SPACE_8}if (null !== result.success) {${R_SPACE_12}return callback(null, result.success)${R_SPACE_8}}${R_SPACE_8}return callback('${key} failed: unknown result')${R_SPACE_4}}`);
            }
        });
        codes.push(`\r\n}`);
        defaultExports.push(name + 'Client');
        return codes.join('');
    };
    const defaultExportsHandler = () => {
        let code = '\r\n\r\nexport default {\r\n';
        defaultExports.forEach((v, i) => {
            code += `    ${v}`;
            if (i < defaultExports.length - 1) {
                code += ',';
            }
            code += '\r\n';
        });
        code += '}\r\n';
        return code;
    };
    if (Request && ast.service) {
        code += `import Request from "${Request}";\r\n`;
    }
    if (ast.include) {
        code += includesHandler(ast.include);
    }
    if (ast.const) {
        code += constsHandler(ast.const);
    }
    if (ast.enum) {
        code += enumsHandler(ast.enum);
    }
    if (ast.exception) {
        code += exceptionsHandler(ast.exception);
    }
    if (ast.struct) {
        code += structsHandler(ast.struct);
    }
    if (ast.union) {
        code += structsLikeHandler(ast.union);
    }
    if (ast.service) {
        code += servicesHandler(ast.service);
    }
    if (ast.service) {
        code += defaultExportsHandler();
    }
    return code;
};
